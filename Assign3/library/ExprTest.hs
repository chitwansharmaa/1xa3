{-|
Module : ExprTest
Description : Checks Functionality and Accuracy of the Library  
Copyright : (c) Chitwan Sharma 2018
License : MIT
Maintainer : sharmc6@mcmaster.ca
Stability : experimental
Portability : DOS
-}
module ExprTest where

import ExprType
import ExprDiff
import ExprParser
import ExprPretty
import Test.QuickCheck

import qualified Data.Map as Map


-- | Property For QuickCheck To Check For Evaluation of a Sample Expression of Type 'Expr Double'
evalDProp :: Double -> Double -- ^ 'Const' Types With Random Doubles Generated By QuickCheck
             -> Bool  
evalDProp i1 i2 = abs((eval (Map.fromList[("x", 2.0)]) (Mult (Add (Const i1) (Const i2)) (Var "x"))) - ((i1+i2)*(2.0))) <= 1.0 

-- | Property For QuickCheck To Check For Evaluation of a Sample Expression of Type 'Expr' 'Float'
evalFProp :: Float -> Float -- ^ 'Const' Types With Random Floats Generated By QuickCheck
             -> Bool
evalFProp i1 i2 = abs((eval (Map.fromList[("x", 2.0)]) (Mult (Add (Const i1) (Const i2)) (Var "x"))) - ((i1+i2)*(2.0))) <= 1.0

-- | Property For QuickCheck To Check For Evaluation of a Partially Differentiated Sample Expression of Type 'Expr' 'Double'
pdDProp :: Double -- ^ Dict With Random 'Double' Generated For Value of x
           -> Bool 
pdDProp d1 = 
    let listd = Map.fromList[("x", d1)]
        expression = (partDiff "x" (Mult (Power (Var "x") (Const 3.0)) (Const 2.0)))
    in abs((eval listd expression) - ((6.0)*(d1**2.0))) <= 1.0

-- | Property For QuickCheck To Check For Evaluation of a Partially Differentiated Sample Expression of Type 'Expr' 'Float'
pdFProp :: Float -- ^ Dict With Random 'Float' Generated For Value of x
           -> Bool
pdFProp d1 = 
    let listd = Map.fromList[("x", d1)]                                                 
        expression = (partDiff "x" (Mult (Power (Var "x") (Const 4.0)) (Const 2.0)))
    in abs((eval listd expression) - ((8.0)*(d1**3.0))) <= 1.0

-- | Property For QuickCheck To Check For The Parsing of a 'String' (With Doubles) in The Format Specified in "ExprParser"
parseDProp :: Double -> Double -> Double -- ^ 'String' With Random Doubles Generated By QuickCheck
              -> Bool
parseDProp d1 d2 d3 =
    if (((abs(d1) >= 9e-1) && (abs(d2) >= 9e-1)) && (abs(d3) >= 9e-1)) then
        let preparse = "((" ++ show d1 ++ "+" ++ show d2 ++ ")" ++ "*" ++ "(cos" ++ show d3 ++ "))" 
        in parseExprD preparse == (Mult (Add (Const d1) (Const d2)) (Cos (Const d3)))
    else True

-- | Property For QuickCheck To Check For The Parsing of a 'String' (With Floats) in The Format Specified in "ExprParser"
parseFProp :: Float -> Float -> Float -- ^ 'String' With Random Doubles Generated By QuickCheck
              -> Bool 
parseFProp d1 d2 d3 =
    if (((abs(d1) >= 9e-1) && (abs(d2) >= 9e-1)) && (abs(d3) >= 9e-1)) then
        let preparse = "((" ++ show d1 ++ "+" ++ show d2 ++ ")" ++ "*" ++ "(cos" ++ show d3 ++ "))"
        in parseExprF preparse == (Mult (Add (Const d1) (Const d2)) (Cos (Const d3)))
    else True

-- | Property For QuickCheck To Check if The Evaluation of a Simplification ('Expr' 'Double') Gives The Right Result
simpDProp :: Double -> Double -- ^ 'Const' Types With Random Doubles Generated By QuickCheck
             -> Bool 
simpDProp d1 d2 =
    let empty = Map.fromList[]
        preSimp = (Mult (Mult (Const d1) (Const d2)) (Mult (Const d1) (Const d2)))
    in abs((eval empty (simplify empty preSimp)) - ((d1*d2)**2)) <= 1.0

-- | Property For QuickCheck To Check if The Evaluation of a Simplification ('Expr' 'Float') Gives The Right Result
simpFProp :: Float -> Float -- ^ 'Const' Types With Random Floats Generated By QuickCheck
             -> Bool 
simpFProp d1 d2 =
    let empty = Map.fromList[]
        preSimp = (Mult (Mult (Const d1) (Const d2)) (Mult (Const d1) (Const d2)))
    in abs((eval empty (simplify empty preSimp)) - ((d1*d2)**2)) <= 1.0